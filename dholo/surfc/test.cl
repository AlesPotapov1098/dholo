// Находим ивертированный битовый адрес.
uint bit_reversed(uint x, uint bits) {
	uint y = 0;
	for (int i = 0; i < bits; i++) {
		y <<= 1;
		y |= x & 1;
		x >>= 1;
	}
	y &= ((1 << bits) - 1);
	return y;
}

// Умножение комплексных чисел типа float2 - вектор
// Тип возвращаемого значеия float2 - вектор
// complex_mul_float2_float2
// c1 = a + ib, c2 = c + id
// result = (ac-bd) + i(ad + bc)
	float2 cmf2f2(float2 c1, float2 c2)
	{
		return (float2)(c1.x * c2.x - c1.y * c2.y, c1.x * c2.y + c1.y * c2.x);
	}

__kernel void testKernel(
	// 0 - Входная последовательность.
		__global float2 * input,
	// 1 - Количество элементов во входной последовательности.
		int NUM_POINTS,
	// 2 - Количество элементов в группе.
		int NUM_POINTS_PER_GROUP,
	// 3 - Локальный массив для обработки.
		__local float2 * arr,
	// 4 - Количество бит.
		uint nbits,
	// 5 - Количество уровней для бабочки, которые могут быть обработаны одной группой
		uint nlevels,
	// 6 - Выходная последовательность (результат перобразования).
		__global float2 * output)
{
	// Номер группы.
		uint group_id = get_group_id(0);

	// Начальный индекс для считывания в локальную память из глобальной.
		uint start_index = get_group_id(0) * NUM_POINTS_PER_GROUP;

	// Заполняем локальный массив значениями из глобального.
	// Элементу локального массива соответствует элемент из глобального массива
	// с инверсией битов относительно текущего индекса для локального массива плюс начальный индекс.
		for(uint i = 0; i < NUM_POINTS_PER_GROUP; i++)
			arr[i] = input[bit_reversed(i + start_index, nbits)];

	// Шаг обхода локального массива, зависит от текущего уровня
		int step = 1;
	
	// Смещение
		int offset = 1;
	
	// Количество циклов
		int cycles = 1;
	
	// Выполняем преобразование Фурье для значений из локального массива.
	// 1 - Обрабатываем по уровням. Максимальный уровень зависит от входного значения nlevels.
		for(int l = 1; l <= nlevels; l++)
		{
			// Задаем шаг, с которым будем идти по локальному массиву.
				step <<= 1;

			// Обрабатываем локальны массив.
			// Количество обработок засисит от значения step, 
			// которое каждый раз увеличивается в 2 раза.
				for(int i = 0; i < NUM_POINTS_PER_GROUP; i += step)
					// Обходим последовательность.
					// Считываем необходиые значения, находим их сумму и разность и записываем обратно.
						for(int j = 0; j < cycles; j++)
						{
							float2 a = arr[i + j];
							float2 b = arr[i + j + offset];

							float2 t = (float2)(cos((2 * M_PI_F * j) / cycles),sin((2 * M_PI_F * j) / cycles));
							b = cmf2f2(b, t);

							arr[i + j] = a + b;
							arr[i + j + offset] = a - b;
						}

			// Изменяем значения смещения и количества циклов обхода
				offset <<= 1;
				cycles <<= 1;
		}

	// Заполняем глобальный результирующий массив
		for(int i = 0; i < NUM_POINTS_PER_GROUP; i++)
			output[group_id * NUM_POINTS_PER_GROUP + i] = arr[i];
}

// Постаобработка последовательности.
// Слияние оставшихся частей по алгоритму бабочка
// Каждая рабочая группа обрабатывает свой участок последовательсноти,
// который в два раза больше предыдущей, следовательсно и групп в два раза меньше.
__kernel void merge(
	// 0 - Входная последовательсноть.
		__global read_write float2 * input,
	// 1 - Количество обрабатываемых элементов (размер).
		int NUM_POINTS)
{
	// Вычисляем количество итераций для алгоритма бабочки.
		uint num_iter = NUM_POINTS / 2;

	// Вычисляем смещение необходимого эелемнта для выполнения преобразования.
		uint offset = NUM_POINTS / 2;

	// Вычисляем адрес, начиная с которого бедм производить преобразование.
		uint addr = get_group_id(0) * NUM_POINTS;

	// Выполняем преобразование исходной последовательсноти по алгоритму бабочки.
		for(int i = 0; i < num_iter; i++)
		{
			float2 a = input[addr + i];
			float2 b = input[addr + i + offset];

			float2 t = (float2)(cos((2 * M_PI_F * i) / num_iter),sin((2 * M_PI_F * i) / num_iter));
			b = cmf2f2(b, t);

			input[addr + i] = a + b;
			input[addr + i + offset] = a - b;
		}
}

