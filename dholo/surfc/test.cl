// Находим ивертированный битовый адрес.
uint bit_reversed(uint x, uint bits) {
	uint y = 0;
	for (int i = 0; i < bits; i++) {
		y <<= 1;
		y |= x & 1;
		x >>= 1;
	}
	y &= ((1 << bits) - 1);
	return y;
}


__kernel void testKernel(
	// 0 - Входная последовательность.
		__global int * input,
	// 1 - Количество элементов во входной последовательности.
		int N,
	// 2 - Количество элементов в группе.
		int Gn,
	// 3 - Локальный массив для обработки.
		__local int * arr,
	// 4 - Количество бит.
		uint bits,
	// 5 - Количество уровней для бабочки, которые могут быть обработаны одной группой
		uint nlevels,
	// 6 - Выходная последовательность (результат перобразования).
		__global int * output)
{
	// Номер группы.
		uint group_id = get_group_id(0);

	// Начальный индекс для считывания в локальную память из глобальной.
		uint start_index = get_group_id(0) * Gn;

	// Заполняем локальный массив значениями из глобального.
	// Элементу локального массива соответствует элемент из глобального массива
	// с инверсией битов относительно текущего индекса для локального массива плюс начальный индекс.
		for(uint i = 0; i < Gn; i++)
			arr[i] = input[bit_reversed(i + start_index, bits)];

	// Шаг обхода локального массива, зависит от текущего уровня
		int step = 1;
	
	// Смещение
		int offset = 1;
	
	// Количество циклов
		int cycles = 1;
	
	// Выполняем преобразование Фурье для значений из локального массива.
	// 1 - Обрабатываем по уровням. Максимальный уровень зависит от входного значения nlevels.
		for(int l = 1; l <= nlevels; l++)
		{
			// Задаем шаг, с которым будем идти по локальному массиву.
				step <<= 1;

			// Обрабатываем локальны массив.
			// Количество обработок засисит от значения step, 
			// которое каждый раз увеличивается в 2 раза.
				for(int i = 0; i < Gn; i += step)
					// Обходим последовательность.
					// Считываем необходиые значения, находим их сумму и разность и записываем обратно.
						for(int j = 0; j < cycles; j++)
						{
							int a = arr[i + j];
							int b = arr[i + j + offset];

							arr[i + j] = a + b;
							arr[i + j + offset] = a - b;
						}

			// Изменяем значения смещения и количества циклов обхода
				offset <<= 1;
				cycles <<= 1;
		}

	// Заполняем глобальный результирующий массив
		for(int i = 0; i < Gn; i++)
			output[group_id * Gn + i] = arr[i];
}
